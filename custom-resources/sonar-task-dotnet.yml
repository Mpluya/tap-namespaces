apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: sonarqube-scanner-dotnet
  labels:
    apps.tanzu.vmware.com/sonarqube: "sonarqube"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/categories: Security
    tekton.dev/tags: security
    tekton.dev/displayName: "sonarqube scanner"
    tekton.dev/platforms: "linux/amd64"
spec:
  params:
    - name: sonar-host-url
      description: Host URL where the sonarqube server is running
      default: ""
    - name: sonar-project-key
      description: Project's unique key
      default: ""
    - name: sonar-token
      description: Auth for the project
      default: ""
    - name: source-url
      description: Location of the source code
    - name: source-revision
      description: i.e. git hash
      default: ""
    - name: wait-on-sonar-analysis
      description: toggle to wait until sonarqube analysis is complete
    - name: source-sub-path
      default: ""

  workspaces:
    - name: supplychain-workspace

  steps:
    - name: pull-code
      image: gradle
      workingDir: $(workspaces.supplychain-workspace.path)
      script: |
        #!/usr/bin/env bash
        set -ex
        wget -qO- $(params.source-url) | tar xvz

    - name: sonar-properties-create
      image: gradle
      workingDir: $(workspaces.supplychain-workspace.path)
      script: |
        #!/usr/bin/env bash
        replaceValues() {
          filename=$1
          thekey=$2
          newvalue=$3
          if ! grep -R "^[#]*\s*${thekey}=.*" $filename >/dev/null; then
            echo "APPENDING because '${thekey}' not found"
            echo "" >>$filename
            echo "$thekey=$newvalue" >>$filename
          else
            echo "SETTING because '${thekey}' found already"
            sed -ir "s|^[#]*\s*${thekey}=.*|$thekey=$newvalue|" $filename
          fi
        }

        # If we were given a properties file, then use that.
        if [[ -f $(workspaces.supplychain-workspace.path)/sonar-project.properties ]]; then
          echo "using user provided sonar-project.properties file"
          cp -RL $(workspaces.supplychain-workspace.path)/sonar-project.properties $(workspaces.supplychain-workspace.path)/sonar-project.properties
        fi
        if [[ -f $(workspaces.supplychain-workspace.path)/sonar-project.properties ]]; then

          # Allow overrides from parameters passed in from the supply chain.
          if [[ -n "$(params.sonar-host-url)" ]]; then
            replaceValues $(workspaces.supplychain-workspace.path)/sonar-project.properties sonar.host.url $(params.sonar-host-url)
          fi
          if [[ -n "$(params.sonar-project-key)" ]]; then
            replaceValues $(workspaces.supplychain-workspace.path)/sonar-project.properties sonar.projectKey $(params.sonar-project-key)
          fi
          if [[ -n "$(params.sonar-token)" ]]; then
            replaceValues $(workspaces.supplychain-workspace.path)/sonar-project.properties sonar.login $(params.sonar-token)
          fi
        else
          touch sonar-project.properties
          echo "sonar.projectKey=$(params.sonar-project-key)" >> sonar-project.properties
          echo "sonar.host.url=$(params.sonar-host-url)" >> sonar-project.properties
          echo "sonar.login=$(params.sonar-token)" >> sonar-project.properties
          echo "sonar.sources=." >> sonar-project.properties
        fi
        echo "---------------------------"
        cat $(workspaces.supplychain-workspace.path)/sonar-project.properties


    - name: sonar-scan
      image: sonarsource/sonar-scanner-cli:latest
      workingDir: $(workspaces.supplychain-workspace.path)
      script: |
        #!/usr/bin/env bash
        set -ex
        SUB_PATH=$(params.source-sub-path)
        if [ -z ${SUB_PATH:-""} ]; then
          echo "INFO: No subpath provided."
        else
          echo "INFO: Changing directory to $SUB_PATH"
          cd $SUB_PATH
        fi

        dotnet sonarscanner begin /k:$(params.sonar-project-key) /d:sonar.login=$(params.sonar-login)
        dotnet build *.sln
        dotnet sonarscanner end /d:sonar.login=$(params.sonar-login)


    - name: quality-gate
      image: 375783000519.dkr.ecr.us-west-2.amazonaws.com/tanzu-application-platform/alpine-curl-jq
      workingDir: $(workspaces.supplychain-workspace.path)
      script: |
        #!/usr/bin/env bash
        if [ -z "$(params.wait-on-sonar-analysis)" ] || [ "$(params.wait-on-sonar-analysis)" == "false" ]; then
          echo "not waiting for analysis to finish"
          exit 0
        fi

        metadataFile=$(workspaces.supplychain-workspace.path)/.scannerwork/report-task.txt
        sonarPropsFile=$(workspaces.supplychain-workspace.path)/sonar-project.properties
        if [[ ! -f "$metadataFile" ]]; then
          echo "$metadataFile does not exist."
          exit 1
        fi

        cat $metadataFile
        serverUrl="$(sed -n 's/serverUrl=\(.*\)/\1/p' "${metadataFile}")"
        ceTaskUrl="$(sed -n 's/ceTaskUrl=\(.*\)/\1/p' "${metadataFile}")"
        sonarToken="$(sed -n 's/sonar.login=\(.*\)/\1/p' "${sonarPropsFile}")"

        if [ -z "${serverUrl}" ] || [ -z "${ceTaskUrl}" ]; then
          echo "Invalid report metadata file."
          exit 1
        fi

        task="$(curl --silent --fail --show-error --user "${sonarToken}": "${ceTaskUrl}")"
        status="$(jq -r '.task.status' <<< "$task")"

        until [[ ${status} != "PENDING" && ${status} != "IN_PROGRESS" ]]; do
          printf '.'
          sleep 5s
          task="$(curl --silent --fail --show-error --user "${sonarToken}": "${ceTaskUrl}")"
          status="$(jq -r '.task.status' <<< "$task")"
        done

        analysisId="$(jq -r '.task.analysisId' <<< "${task}")"
        echo "analysisId: " $analysisId
        
        qualityGateUrl="${serverUrl}/api/qualitygates/project_status?analysisId=${analysisId}"
        
        qualityGateStatus="$(curl --silent --fail --show-error --user "${sonarToken}": "${qualityGateUrl}" | jq -r '.projectStatus.status')"

        if [[ ${qualityGateStatus} == "OK" ]]; then
          echo "quality-gate-status::PASSED"
        elif [[ ${qualityGateStatus} == "WARN" ]]; then
          echo "quality-gate-status::WARN"
        elif [[ ${qualityGateStatus} == "ERROR" ]]; then
          echo "quality-gate-status::FAILED"
          exit 1
        else
          echo "quality-gate-status::FAILED"
          exit 1
        fi